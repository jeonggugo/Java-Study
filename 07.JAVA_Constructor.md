## **생성자** - **필요한** **이유**

객체를 생성하는 시점에 어떤 작업을 하고 싶다면 생성자(Constructor)를 이용하면 된다.

생성자를 알아보기 전에 먼저 생성자가 왜 필요한지 코드로 간단히 알아보자.

**MemberInit**

```jsx
package construct;
public class MemberInit {
String name;
int age;
int grade;
}
```

**MethodInitMain1**

```jsx
package construct;
public class MethodInitMain1 {
public static void main(String[] args) {
MemberInit member1 = new MemberInit();
member1.name = "user1";
member1.age = 15;
member1.grade = 90;
MemberInit member2 = new MemberInit();
member2.name = "user2";
member2.age = 16;
member2.grade = 80;
MemberInit[] members = {member1, member2};
for (MemberInit s : members) {
System.out.println("이름:" + s.name + " 나이:" + s.age + " 성적:" +
s.grade);
	}
}
```

****실행** **결과****

```jsx
이름:user1 나이:15 성적:90
이름:user2 나이:16 성적:80
```

회원 객체를 생성하고 나면 `name` , `age` , `grade` 같은 변수에 초기값을 설정한다. 아마도 회원 객체를 제대로 사용하기 위해서는 객체를 생성하자 마자 이런 초기값을 설정해야 할 것이다.

```jsx
package construct;
public class MethodInitMain2 {
public static void main(String[] args) {
MemberInit member1 = new MemberInit();
initMember(member1, "user1", 15, 90);
MemberInit member2 = new MemberInit();
initMember(member2, "user2", 16, 80);
MemberInit[] members = {member1, member2};
for (MemberInit s : members) {
System.out.println("이름:" + s.name + " 나이:" + s.age + " 성적:" +
s.grade);
	}
}
static void initMember(MemberInit member, String name, int age, int grade)
{
member.name = name;
member.age = age;
member.grade = grade;
	}
}
```

`initMember(...)` 메서드를 사용해서 반복을 제거했다. 그런데 이 메서드는 대부분 `MemberInit` 객체의 멤버 변수를 사용한다. 

우리는 앞서 객체 지향에 대해서 학습했다. 이런 경우 속성과 기능을 한 곳에 두는 것이 더 나은 방법이다. 

쉽게 이야기해서 `MemberInit` 이 자기 자신의 데이터를 변경하는 기능(메서드)을 제공하는 것이 좋다.

## this

멤버 변수와 메서드의 매개변수의 이름이 같으면 둘을 어떻게 구분해야 할까?

이 경우 멤버 변수보다 매개변수가 코드 블럭의 더 안쪽에 있기 때문에 ****매개변수가** **우선순위****를 가진다. 따라서

`initMember(String name,...)` 메서드 안에서 `name` 이라고 적으면 매개변수에 접근하게 된다.

멤버 변수에 접근하려면 앞에 `this.` 이라고 해주면 된다. 여기서 `this` 는 인스턴스 자신의 참조값을 가리킨다.

![image.png](attachment:bf786293-ef74-44a9-9a53-e94eadf37004:image.png)

****진행** **과정****

```jsx
this.name = name; //1. 오른쪽의 name은 매개변수에 접근
this.name = "user"; //2. name 매개변수의 값 사용
x001.name = "user"; //3. this.은 인스턴스 자신의 참조값을 뜻함, 따라서 인스턴스의 멤버 변수에
접근
```

**this **제거****

만약 이 예제에서 `this` 를 제거하면 어떻게 될까?

```jsx
this.name = name
```

다음과 같이 수정하면 `name` 은 둘다 매개변수를 뜻하게 된다. 따라서 맴버변수의 값이 변경되지 않는다.

```jsx
name = name
```

**정리**

- 매개변수의 이름과 맴버 변수의 이름이 같은 경우 `this` 를 사용해서 둘을 명확하게 구분해야 한다.
- `this` 는 인스턴스 자신을 가리킨다.
- ## **생성자** - **도입**

프로그래밍을 하다보면 객체를 생성하고 이후에 바로 초기값을 할당해야 하는 경우가 많다. 따라서 앞서

`initMember(...)` 와 같은 메서드를 매번 만들어야 한다.

그래서 대부분의 객체 지향 언어는 객체를 생성하자마자 즉시 필요한 기능을 좀 더 편리하게 수행할 수 있도록 생성자라는 기능을 제공한다. 생성자를 사용하면 객체를 생성하는 시점에 즉시 필요한 기능을 수행할 수 있다.

생성자는 메서드와 비슷하지만 다음과 같은 차이가 있다.

- 생성자의 이름은 클래스 이름과 같아야 한다. 따라서 첫 글자도 대문자로 시작한다.
- 생성자는 반환 타입이 없다. 비워두어야 한다.
- 나머지는 메서드와 같다.

## **생성자** **장점**

***중복** **호출** **제거***

생성자가 없던 시절에는 생성 직후에 어떤 작업을 수행하기 위해 다음과 같이 메서드를 직접 한번 더 호출해야했다. 

생성자 덕분에 객체를 생성하면서 동시에 생성 직후에 필요한 작업을 한번에 처리할 수 있게 되었다.

***제약** - **생성자** **호출** **필수***

방금 코드에서 생성자 등장 전 코드를 보자. 이 경우 `initMember(...)` 를 실수로 호출하지 않으면 어떻게 될까? 이 메서드를 실수로 호출하지 않아도 프로그램은 작동한다. 

하지만 회원의 이름과 나이, 성적 데이터가 없는 상태로 프로그램이 동작하게 된다. 만약에 이 값들을 필수로 반드시 입력해야 한다면, 시스템에 큰 문제가 발생할 수 있다. 

결국 아무정보가 없는 유령 회원이 시스템 내부에 등장하게 된다.생성자의 진짜 장점은 객체를 생성할 때 직접 정의한 생성자가 있다면 ****직접** **정의한** **생성자를** **반드시** **호출****해야 한다는 점이다.

 참고로 생성자를 메서드 오버로딩 처럼 여러개 정의할 수 있는데, 이 경우에는 하나만 호출하면 된다.

`MemberConstruct` 클래스의 경우 다음 생성자를 직접 정의했기 때문에 직접 정의한 생성자를 반드시 호출해야 한다.

***기본** **생성자***

- 매개변수가 없는 생성자를 기본 생성자라 한다.
- 클래스에 생성자가 하나도 없으면 자바 컴파일러는 매개변수가 없고, 작동하는 코드가 없는 기본 생성자를 자동으로 만들어준다.
- ***생성자가** **하나라도** **있으면** **자바는** **기본** **생성자를** **만들지** **않는다**.**

***기본** **생성자를** **왜** **자동으로** **만들어줄까**?**

만약 자바에서 기본 생성자를 만들어주지 않는다면 생성자 기능이 필요하지 않은 경우에도 모든 클래스에 개발자가 직접 기본 생성자를 정의해야 한다. 생성자 기능을 사용하지 않는 경우도 많기 때문에 이런 편의 기능을 제공한다.

## ***정리***

- 생성자는 반드시 호출되어야 한다.
- 생성자가 없으면 기본 생성자가 제공된다.
- ***생성자가** **하나라도** **있으면** **기본** **생성자가** **제공되지** **않는다**.** 이 경우 개발자가 정의한 생성자를 직접 호출해야 한다.
