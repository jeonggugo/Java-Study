# 접근 제어자 이해

## **접근** **제어자** **이해1**

자바는 `public` , `private` 같은 접근 제어자(access modifier)를 제공한다. 접근 제어자를 사용하면 해당 클래스 외부에서 특정 필드나 메서드에 접근하는 것을 허용하거나 제한할 수 있다.

이런 접근 제어자가 왜 필요할까? 예제를 통해 접근 제어자가 필요한 이유를 알아보자.

여러분은 스피커에 들어가는 소프트웨어를 개발하는 개발자다.

스피커의 음량은 절대로 100을 넘으면 안된다는 요구사항이 있다. (**100**을** **넘어가면** **스피커의** **부품들이** **고장난다**.**)

스피커 객체를 만들어보자.

스피커는 음량을 높이고, 내리고, 현재 음량을 확인할 수 있는 단순한 기능을 제공한다.

요구사항 대로 스피커의 음량은 100까지만 증가할 수 있다. 절대 100을 넘어가면 안된다.

Speaker

```jsx
package access;
public class Speaker {
int volume;
Speaker(int volume) {
this.volume = volume;
}
void volumeUp() {
if (volume >= 100) {
} else {
System.out.println("음량을 증가할 수 없습니다. 최대 음량입니다.");
volume += 10;
System.out.println("음량을 10 증가합니다.");
	}
}
void volumeDown() {
volume -= 10;
System.out.println("volumeDown 호출");
}
void showVolume() {
System.out.println("현재 음량:" + volume);
	}
}
```

생성자를 통해 초기 음량 값을 지정할 수 있다.
`volumeUp()` 메서드를 보자. 음량을 한번에 10씩 증가한다. 단 음량이 100을 넘게되면 더는 음량을 증가하지 않는다.

**SpeakerMain

```jsx
package access;
public class SpeakerMain {
public static void main(String[] args) {
Speaker speaker = new Speaker(90);
speaker.showVolume();
speaker.volumeUp();
speaker.showVolume();
speaker.volumeUp();
speaker.showVolume();
	}
}
```

*실행결과

```jsx
현재 음량: 90
음량을 10 증가합니다.
현재 음량: 100
음량을 증가할 수 없습니다. 최대 음량입니다.
현재 음량: 100
```

초기 음량 값을 90으로 지정했다. 그리고 음량을 높이는 메서드를 여러번 호출했다.
기대한 대로 음량은 100을 넘지 않았다. 프로젝트는 성공적으로 끝났다.
오랜 시간이 흘러서 업그레이드 된 다음 버전의 스피커를 출시하게 되었다. 이때는 새로운 개발자가 급하게 기존 코드를이어받아서 개발을 하게 되었다. 참고로 새로운 개발자는 기존 요구사항을 잘 몰랐다. 코드를 실행해보니 이상하게 음량이 100이상 올라가지 않았다. 소리를 더 올리면 좋겠다고 생각한 개발자는 다양한 방면으로 고민했다.
`Speaker` 클래스를 보니 `volume` 필드를 직접 사용할 수 있었다. `volume` 필드의 값을 200으로 설정하고 이 코드를 실행한 순간 스피커의 부품들에 과부하가 걸리면서 폭발했다.

**SpeakerMain - **필드** **직접** **접근** **코드** **추가****

```jsx
package access;
public class SpeakerMain {
public static void main(String[] args) {
Speaker speaker = new Speaker(90);
speaker.showVolume();
speaker.volumeUp();
speaker.showVolume();
speaker.volumeUp();
speaker.showVolume();
//필드에 직접 접근
System.out.println("volume 필드 직접 접근 수정");
speaker.volume = 200;
speaker.showVolume();
	}
}

```

실행결과

```jsx
현재 음량: 90
음량을 10 증가합니다.
현재 음량: 100
음량을 증가할 수 없습니다. 최대 음량입니다.
현재 음량: 100
volume 필드 직접 접근 수정
현재 음량: 200
```

![image.png](attachment:5ef2218f-e134-4bbc-af69-b6540fb7b3d9:image.png)

`Speaker` 객체를 사용하는 사용자는 `Speaker` 의 `volume` 필드와 메서드에 모두 접근할 수 있다.
앞서 `volumeUp()` 과 같은 메서드를 만들어서 음량이 100을 넘지 못하도록 기능을 개발했지만 소용이 없다. 왜냐하면 `Speaker` 를 사용하는 입장에서는 `volume` 필드에 직접 접근해서 원하는 값을 설정할 수 있기 때문이다.
이런 문제를 근본적으로 해결하기 위해서는 `volume` 필드의 외부 접근을 막을 수 있는 방법이 필요하다.

## **접근** **제어자** **이해**2

이 문제를 근본적으로 해결하는 방법은 `volume` 필드를 `Speaker` 클래스 외부에서는 접근하지 못하게 막는 것이다.

Speaker - volume **접근** **제어자를** private**으로** **수정****

```jsx
package access;
public class Speaker {
private int volume; //private 사용
...
}
```

`private` 접근 제어자는 모든 외부 호출을 막는다. 따라서 `private` 이 붙은 경우 해당 클래스 내부에서만 호출할 수있다.

![image.png](attachment:02b1cacd-1962-421c-8373-ae33fce6d7fb:image.png)

그림을 보면 `volume` 필드를 `private` 을 사용해서 `Speaker` 내부에 숨겼다.
외부에서 `volume` 필드에 직접 접근할 수 없게 막은 것이다. `volume` 필드는 이제 `Speaker` 내부에서만 접근할 수있다.

## **접근** **제어자** **종류**

자바는 4가지 종류의 접근 제어자를 제공한다.

***접근** **제어자의** **종류***

- `private` : 모든 외부 호출을 막는다.
- `default` (package-private): 같은 패키지안에서 호출은 허용한다.
- `protected` : 같은 패키지안에서 호출은 허용한다. 패키지가 달라도 상속 관계의 호출은 허용한다.
- `public` : 모든 외부 호출을 허용한다.
- 

순서대로 `private` 이 가장 많이 차단하고, `public` 이 가장 많이 허용한다.

`private -> default -> protected -> public`

참고로 `protected` 는 상속 관계에서 자세히 설명한다.

**package-private**

접근 제어자를 명시하지 않으면 같은 패키지 안에서 호출을 허용하는 `default` 접근 제어자가 적용된다.

`default` 라는 용어는 해당 접근 제어자가 기본값으로 사용되기 때문에 붙여진 이름이지만, 실제로는 `package-private` 이 더 정확한 표현이다. 왜냐하면 해당 접근 제어자를 사용하는 멤버는 동일한 패키지 내의 다른 클래스에서만 접근이 가능하기 때문이다. 참고로 두 용어를 함께 사용한다.

***접근** **제어자** **사용** **위치***

접근 제어자는 필드와 메서드, 생성자에 사용된다.

추가로 클래스 레벨에도 일부 접근 제어자를 사용할 수 있다. 이 부분은 뒤에서 따로 설명한다.

****접근** **제어자** **예시****

```jsx
public class Speaker { //클래스 레벨
private int volume; //필드
public Speaker(int volume) {} //생성자
public void volumeUp() {} //메서드
public void volumeDown() {}
public void showVolume() {}
}
```

***접근** **제어자의** **핵심은** **속성과** **기능을** **외부로부터** **숨기는** **것이다**.**

- `private` 은 나의 클래스 안으로 속성과 기능을 숨길 때 사용, 외부 클래스에서 해당 기능을 호출할 수 없다.
- `default` 는 나의 패키지 안으로 속성과 기능을 숨길 때 사용, 외부 패키지에서 해당 기능을 호출할 수 없다.
- `protected` 는 상속 관계로 속성과 기능을 숨길 때 사용, 상속 관계가 아닌 곳에서 해당 기능을 호출할 수 없다.
- `public` 은 기능을 숨기지 않고 어디서든 호출할 수 있게 공개한다.

## **접근** **제어자** **사용** - **클래스** **레벨**

***클래스** **레벨의** **접근** **제어자** **규칙***

- 클래스 레벨의 접근 제어자는 `public` , `default` 만 사용할 수 있다.
    - `private` , `protected` 는 사용할 수 없다.
- `public` 클래스는 반드시 파일명과 이름이 같아야 한다.
    - 하나의 자바 파일에 `public` 클래스는 하나만 등장할 수 있다.
    - 하나의 자바 파일에 `default` 접근 제어자를 사용하는 클래스는 무한정 만들 수 있다.

## **캡슐화**

캡슐화(Encapsulation)는 객체 지향 프로그래밍의 중요한 개념 중 하나다. 캡슐화는 데이터와 해당 데이터를 처리하는 메서드를 하나로 묶어서 외부에서의 접근을 제한하는 것을 말한다. 캡슐화를 통해 데이터의 직접적인 변경을 방지하거나 제한할 수 있다.

캡슐화는 쉽게 이야기해서 속성과 기능을 하나로 묶고, 외부에 꼭 필요한 기능만 노출하고 나머지는 모두 내부로 숨기는것이다.

이전에 객체 지향 프로그래밍을 설명하면서 캡슐화에 대해 알아보았다. 이때는 데이터와 데이터를 처리하는 메서드를 하나로 모으는 것에 초점을 맞추었다. 여기서 한발짝 더 나아가 캡슐화를 안전하게 완성할 수 있게 해주는 장치가 바로 접근 제어자다.

그럼 어떤 것을 숨기고 어떤 것을 노출해야 할까?

*1. **데이터를** **숨겨라***

객체에는 속성(데이터)과 기능(메서드)이 있다. 캡슐화에서 가장 필수로 숨겨야 하는 것은 속성(데이터)이다.

`Speaker` 의 `volume` 을 떠올려보자. 객체 내부의 데이터를 외부에서 함부로 접근하게 두면, 클래스 안에서 데이터를 다루는 모든 로직을 무시하고 데이터를 변경할 수 있다. 결국 모든 안전망을 다 빠져나가게 된다. 따라서 캡슐화가 깨진다.

우리가 자동차를 운전할 때 자동차 부품을 다 열어서 그 안에 있는 속도계를 직접 조절하지 않는다. 단지 자동차가 제공하는 엑셀 기능을 사용해서 엑셀을 밟으면 자동차가 나머지는 다 알아서 하는 것이다.

우리가 일상에서 생각할 수 있는 음악 플레이어를 떠올려보자. 음악 플레이어를 사용할 때 그 내부에 들어있는 전원부나, 볼륨 상태의 데이터를 직접 수정할 일이 있을까? 우리는 그냥 음악 플레이어의 켜고, 끄고, 볼륨을 조절하는 버튼을누를 뿐이다. 그 내부에 있는 전원부나, 볼륨의 상태 데이터를 직접 수정하지 않는다. 전원 버튼을 눌렀을 때 실제 전원을 받아서 전원을 켜는 것은 음악 플레이어의 일이다. 

볼륨을 높였을 때 내부에 있는 볼륨 장치들을 움직이고 볼륨 수치를 조절하는 것도 음악 플레이어가 스스로 해야하는 일이다. 쉽게 이야기해서 우리는 음악 플레이어가 제공하는 기능을통해서 음악 플레이어를 사용하는 것이다. 복잡하게 음악 플레이어의 내부를 까서 그 내부 데이터까지 우리가 직접 사용하는 것은 아니다.

***객체의** **데이터는** **객체가** **제공하는** **기능인** **메서드를** **통해서** **접근해야** **한다**.****

2. **기능을** **숨겨라***

객체의 기능 중에서 외부에서 사용하지 않고 내부에서만 사용하는 기능들이 있다. 이런 기능도 모두 감추는 것이 좋다.

우리가 자동차를 운전하기 위해 자동차가 제공하는 복잡한 엔진 조절 기능, 배기 기능까지 우리가 알 필요는 없다. 우리는 단지 엑셀과 핸들 정도의 기능만 알면 된다.

만약 사용자에게 이런 기능까지 모두 알려준다면, 사용자가 자동차에 대해 너무 많은 것을 알아야 한다.

사용자 입장에서 꼭 필요한 기능만 외부에 노출하자. 나머지 기능은 모두 내부로 숨기자

정리하면 데이터는 모두 숨기고, 기능은 꼭 필요한 기능만 노출하는 것이 좋은 캡슐화이다.
