# 배열

**배열의** **선언과** **생성**

배열은 같은 타입의 변수를 사용하기 편하게 하나로 묶어둔 것이다. 이전 예제를 배열을 사용하도록 변경해보자.

참고로 단계적으로 구조를 변경해 나갈 것이다.

**1. **배열** **변수** **선언****

<img width="1534" height="316" alt="image" src="https://github.com/user-attachments/assets/7d539793-4eed-4afc-a56a-43afc8100bd9" />


- 배열을 사용하려면 `int[] students;` 와 같이 배열 변수를 선언해야 한다.
- 일반적인 변수와 차이점은 `int[]` 처럼 타입 다음에 대괄호(`[]` )가 들어간다는 점이다.
- 배열 변수를 선언한다고해서 아직 사용할 수 있는 배열이 만들어진 것은 아니다!
    - `int a` 에는 정수를, `double b` 에는 실수를 담을 수 있다.
    - `int[] students` 와 같은 배열 변수에는 배열을 담을 수 있다. (배열 변수에는 10, 20 같은 값이 아라
    배열이라는 것을 담을 수 있다)

**2. **배열** **생성****

<img width="1870" height="258" alt="image" src="https://github.com/user-attachments/assets/ab80fe39-c033-4e21-9a2a-8810ea1504b3" />


- 배열을 사용하려면 배열을 생성해야 한다.
- `new int[5]` 라고 입력하면 오른쪽 그림과 같이 총 5개의 `int` 형 변수가 만들어진다.
- `new` 는 새로 생성한다는 뜻이고, `int[5]` 는 `int` 형 변수 5개라는 뜻이다. 따라서 `int` 형 변수 5개를 다룰 수있는 배열을 새로 만든다는 뜻이다.
- 앞서 `int student1` , `int student2` ... `int student5` 까지 총 5개의 변수를 직접 선언했다. 배열을 사용하면 이런 과정을 한번에 깔끔하게 처리할 수 있다.

****배열과** **초기화****

- `new int[5]` 라고 하면 총 5개의 `int` 형 변수가 만들어진다. 자바는 배열을 생성할 때 그 내부값을 자동으로초기화한다.
- 숫자는 `0` , `boolean` 은 `false` , `String` 은 `null` (없다는 뜻이다.)로 초기화 된다.

**3. **배열** **참조값** **보관****

<img width="1870" height="258" alt="image" src="https://github.com/user-attachments/assets/c8f4f750-fd7c-4f49-aef7-c2d3402d6ef5" />


- `new int[5]`로 배열을 생성하면 배열의 크기만큼 메모리를 확보한다.
    - `int` 형을 5개 사용하면 `4byte * 5` `20byte` 를 확보한다.
- 배열을 생성하고 나면 자바는 메모리 어딘가에 있는 이 배열에 접근할 수 있는 참조값(주소)(`x001` )을 반환한다.
    - 여기서 `x001` 이라고 표현한 것이 참조값이다. (실제로 `x001` 처럼 표현되는 것은 아니고 이해를 돕기 위한예시이다.)
- 앞서 선언한 배열 변수인 `int[]` int[] students`변수는`new int[5] `students` 에 생성된 배열의 참조값(`x001` )을 보관한다.
- int[ ] students 변수는 new int[5]로 생성한 배열의 참조값을 가지고 있다.
    - 이 변수는 참조값을 가지고 있다. 이 참조값을 통해 배열을 참조할 수 있다. 쉽게 이야기해서 참조값을 통해메모리에 있는 실제 배열에 접근하고 사용할 수 있다.
    - 참고로 배열을 생성하는 `new int[5]` 자체에는 아무런 이름이 없다! 그냥 `int` 형 변수를 5개 연속으로만드는 것이다. 따라서 생성한 배열에 접근하는 방법이 필요하다. 따라서 배열을 생성할 때 반환되는 참조값을 어딘가에 보관해두어야 한다. 앞서 `int[] 를 통해서 이 배열에 접근할 수 있다.

**리펙토링이란?**

리펙토링(Refactoring)은 기존의 코드의 기능은 유지하면서 내부 구조를 개선하여 가독성을 높이고, 유지보스를 용이하게 하는 과정을 뜻한다. 이는 중복을 제거하고, 복잡성을 줄이며, 이해하기 쉬운 코드로 만들기 위해 수행된다. 리펙토링은 버그를 줄이고, 프로그램의 성능을 향상시킬 수도 있으며, 코드의 설계를 개선하는 데에도 많은 도움이 된다. 쉽게 이야기해서 작동하는 기능은 똑같은데, 코드를 개선하는 것을 리펙토링이라 한다.

**배열** **리펙토링** - **초기화**

배열은 `{}` 를 사용해서 생성과 동시에 편리하게 초기화 하는 기능을 제공한다.

```jsx
int[] students;
students = new int[]{90, 80, 70, 60, 50}; //배열 생성과 초기화
```

**Array1Ref3//예제3번**

```jsx
package array;
public class Array1Ref3 {
public static void main(String[] args) {
int[] students;
students = new int[]{90, 80, 70, 60, 50}; //배열 생성과 초기화
for (int i = 0; i < students.length; i++) {
System.out.println("학생" + (i + 1) + " 점수: " + students[i]);
		}
	}
}
```

이해를 돕기 위해 배열 변수의 선언과 배열의 생성 및 초기화를 두 줄로 나누었지만 다음과 같이 한줄도 가능하다.

```jsx
int[] students = new int[]{90, 80, 70, 60, 50}; //배열 변수 선언, 배열 생성과 초기화
```

**배열** **리펙토링** - **간단한** **배열** **생성**

배열은 `{}` 만 사용해서 생성과 동시에 편리하게 초기화 하는 기능을 제공한다.

****배열의** **편리한** **초기화****

```jsx
int[] students = {90, 80, 70, 60, 50};
```

단 이때는 예제와 같이 배열 변수의 선언을 한 줄에 함께 사용할 때만 가능하다.
물론 이렇게 하더라도 자바가 내부에서 배열 요소의 크기를 보고
`new 기존 코드를 조금 더 편리하게 사용할 수 있는 편의 기능이라 생각하면 된다. int[5]` 을 사용

**오류****

```jsx
int[] students;
students = {90, 80, 70, 60, 50};//배열이 int형인지 따로 인식할 수가 없음.
```

******향상된 for문******

앞서 반복문에서 설명하지 않은 내용이 하나 있는데, 바로 향상된 for문(Enhanced For Loop)이다. 향상된 for문을이해하려면 배열을 먼저 알아야 한다. 각각의 요소를 탐색한다는 의미로 for-each문이라고도 많이 부른다.
향상된 `for` 문은 배열을 사용할 때 기존 `for` 문 보다 더 편리하게 사용할 수 있다.

****향상된** for**문** **정의****

```jsx
for (변수 : 배열 또는 컬렉션) {
// 배열 또는 컬렉션의 요소를 순회하면서 수행할 작업
}
```

```jsx
        int[] numbers = {1, 2, 3, 4, 5};
```

이러한 1차원 배열이 존재한다고 하자.

우리는 보통 이 배열의 값을 int 변수에 옴기고 그 값을 출력하기 위해 아래와 같은 코드를 작성하여 출력할 것이다.

```jsx
        for(int i = 0; i < numbers.length; i++) {
            int number = numbers[i];
            System.out.println(number);
        }

```

하지만 for문은 더 향상된 기능을 제공하고있다.

```jsx
        //향상된 forans, for-each문
        for(int number: numbers) {
            System.out.println(number);
        }
```

위 코드를 보면 for문을 통해 numbers라는 배열을 처음부터 끝까지 순회하면서 nuber에 값을 넣어주며 출력하는 것을 확인할 수 있다.

- 앞서 일반 for문과 동일하게 작동한다.
- 향상된 for문은 배열의 인덱스를 사용하지 않고, 종료 조건을 주지 않아도 된다. 단순히 해당 배열을 처음부터 끝까지 탐색한다.
- `:` 의 오른쪽에 `numbers` 와 같이 탐색할 배열을 선택하고, `:` 의 왼쪽에 `int number` 와 같이 반복할 때 마다 찾은 값을 저장할 변수를 선언한다. 그러면 배열의 값을 하나씩 꺼내서 왼쪽에 있는 `number` 에 담고 for문을 수행한다. for문의 끝에 가면 다음 값을 꺼내서 `number` 에 담고 for문을 반복 수행한다. `numbers` 배열의 끝에 도달해서 더 값이 없으면 for문이 완전히 종료된다.
- 향상된 for문은 배열의 인덱스를 사용하지 않고도 배열의 요소를 순회할 수 있기 때문에 코드가 간결하고 가독성이 좋다.
